package org.apache.solr.analysis;import java.io.IOException;import java.util.Collections;import java.util.Map;import java.util.Set;import java.util.TreeMap;import java.util.Map.Entry;import org.apache.lucene.analysis.TokenFilter;import org.apache.lucene.analysis.TokenStream;import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;import org.apache.lucene.analysis.tokenattributes.TypeAttribute;import org.apache.solr.common.SolrInputDocument;/** * This token filter collects all tokens by type (except those specified in * <code>ignoreTypes</code> parameter), and when {@link #end()} is called it * adds the collected tokens to the input <code>solrDocument</code>, either * as a single field named <code>fieldName</code>, or in case of the types * specified in <code>splitTypes</code> to separate fields with field names * of the form <code>type_fieldName</code>. */public final class TypeAsFieldFilter extends TokenFilter {    private String fieldName;  private SolrInputDocument solrDocument;  private CharTermAttribute termAttr;  private TypeAttribute typeAttr;  private Map<String, StringBuilder> textByType =    new TreeMap<String, StringBuilder>();  private Set<String> splitTypes;  private Set<String> ignoreTypes;  public TypeAsFieldFilter(TokenStream input, SolrInputDocument solrDocument,          String fieldName, Set<String> splitTypes, Set<String> ignoreTypes) {    super(input);    this.fieldName = fieldName;    this.solrDocument = solrDocument;    if (splitTypes != null) {      this.splitTypes = splitTypes;    } else {      this.splitTypes = Collections.EMPTY_SET;    }    if (ignoreTypes != null) {      this.ignoreTypes = ignoreTypes;    } else {      this.ignoreTypes = Collections.EMPTY_SET;    }    termAttr = input.addAttribute(CharTermAttribute.class);    typeAttr = input.addAttribute(TypeAttribute.class);  }    @Override  public boolean incrementToken() throws IOException {    if (input.incrementToken()) {      if (!ignoreTypes.contains(typeAttr.type())) {        StringBuilder sb = textByType.get(typeAttr.type());        if (sb == null) {          sb = new StringBuilder();          textByType.put(typeAttr.type(), sb);        }        if (sb.length() > 0) sb.append(' ');        sb.append(termAttr.toString());      }      return true;    } else {      return false;    }  }  @Override  public void end() throws IOException {    super.end();    if (textByType.size() > 0 && solrDocument != null) {      for (Entry<String, StringBuilder> e : textByType.entrySet()) {        if (splitTypes.contains(e.getKey())) {          String k = e.getKey().replaceAll("[<>\\- ]", "_").toLowerCase();          solrDocument.addField(k + "_" + fieldName, e.getValue().toString());        } else {          solrDocument.addField(fieldName, e.getValue().toString());        }      }    }  }  @Override  public void reset() throws IOException {    super.reset();    textByType.clear();  }}